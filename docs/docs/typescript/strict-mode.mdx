---
title: TypeScript Strict Mode
description: TS Strict mode, tips and tricks
---

import CodeBlock from '@theme/CodeBlock';

Wow, looks like you're ready to level up your TypeScript game! Redwood does support strict mode, but does not enable it by default. While strict mode does indeed give you a lot more safety, it does make your code a bit more verbose - and will require you to make small manual changes if you use the CLI to generate your services and components.

## Enabling strict mode
Once you enable strict mode, by modifying TypeScript settings, in `web/tsconfig.json` and `api/tsconfig.json`

```js
{
  "compilerOptions": {
    "noEmit": true,
    "allowJs": true,
 // highlight-next-line
    "strict": true,
```

Redwood's type generators will tweak the generated types too, so make sure you run `yarn rw g types` after!

## Manual tweaks to generated code
This section will cover the various changes you'll need to make, once in strict mode, to remove those pesky red underlines!

### Service tests on the API side
By default Redwood's generators assume that service functions don't require any function parameters.

While this is true, in the strictest sense, all GraphQL resolvers take some sort of input, so you'll need to modify the test, and usages of your service functions that have been typed with `QueryResolvers` or `MutationResolvers`

```js
// api/src/services/posts/posts.test.ts

scenario('returns all posts', async (scenario: StandardScenario) => {
  const result = await posts() // ðŸ›‘ error
  const result = await posts({}) // âœ…
```

### Returning `Prisma.findUnique` operations in services
In strict mode, TypeScript will become a lot more pedantic about null checks, in particular whenever you use Prisma's `findUnique` in the resolvers.

The tension here is that Prisma returns Promises in the form `Promise<Model | null>`, while the resolver types expect it in the form `Promise<Model> | Promise<null>`. In runtime, this has no effect however the TS compiler needs to be told that its okay!

```ts
export const post: QueryResolvers['post'] = ({ id }) => {
  return db.post.findUnique({
    where: { id },
  })
  // highlight-next-line
  as Promise<Post> | Promise<null>
}
```
You will need to change this in all the services that return directly from a `findUnique` operation.


### Handling null vs undefined in Service functions
One of the challenges in the GraphQL-Prisma world is the difference in the way it treats optionals.

- For GraphQL - optional fields can be `null`
- But... For Prisma - `null` is a value, `undefined` means "do nothing"

This is convered in detail in [Prisma's docs](https://www.prisma.io/docs/concepts/components/prisma-client/null-and-undefined) - which we strongly recommend reading.

For "create" and "update" operations, you'll have to make sure `nulls` are converted to `undefined` from your mutation inputs. One way to do this would be to use the library [dnull](https://www.npmjs.com/package/dnull)

```ts
import { dnull } from "dnull"

export const updateUser: MutationResolvers["updateUser"] = ({ id, input }) => {
  return db.user.update({
    data: dnull(input),
    where: { id },
  })
}
```

### Roles checks for CurrentUser in `src/lib/auth`
When you setup auth in your project using `yarn rw setup auth <provider>` - we include some template code for handling roles with the `hasRole` function.

While we do runtime checks here to make sure we don't access roles if it doesn't exist, TypeScript in strict mode will highlight errors, depending on


```typescript
export const hasRole = (roles: AllowedRoles): boolean => {
  if (!isAuthenticated()) {
    return false
  }

  // highlight-next-line
  const currentUserRoles = context.currentUser?.roles
  // Error: Property 'roles' does not exist on type '{ id: number; }'.ts(2339)
```

You will have to adjust the generated code, depending on how your user model is setup.

<details>
<summary>Example code diffs</summary>

#### A. If your project does not use roles
If you CurrentUser does not return `roles`, and you do not use this functionality, you can safely remove the `hasRoles` function.


#### B. Roles on current user is a string
Alternatively, if  you define the roles as a string, you can remove the code that does checks against Arrays

```diff
export const hasRole = (roles: AllowedRoles): boolean => {
  if (!isAuthenticated()) {
    return false
  }

  const currentUserRoles = context.currentUser?.roles

  if (typeof roles === 'string') {
-    if (typeof currentUserRoles === 'string') {
      return currentUserRoles === roles
-    }
  }

  if (Array.isArray(roles)) {
-    if (Array.isArray(currentUserRoles)) {
-      return currentUserRoles?.some((allowedRole) =>
-        roles.includes(allowedRole)
-      )
-    } else if (typeof context?.currentUser?.roles === 'string') {
      // roles to check is an array, currentUser.roles is a string
      return roles.some(
        (allowedRole) => context.currentUser?.roles === allowedRole
      )
-    }
  }

  // roles not found
  return false
}
```


#### C. Roles on current user is an Array of strings
If in your User model, roles are an array of strings, and can never be just a string, you can safely remove the code

```diff
export const hasRole = (roles: AllowedRoles): boolean => {
  if (!isAuthenticated()) {
    return false
  }

 const currentUserRoles = context.currentUser?.roles

  if (typeof roles === 'string') {
-    if (typeof currentUserRoles === 'string') {
-      return currentUserRoles === roles
-    } else if (Array.isArray(currentUserRoles)) {
      // roles to check is a string, currentUser.roles is an array
      return currentUserRoles?.some((allowedRole) => roles === allowedRole)
-    }
  }

  if (Array.isArray(roles)) {
-    if (Array.isArray(currentUserRoles)) {
      return currentUserRoles?.some((allowedRole) =>
        roles.includes(allowedRole)
      )
-    } else if (typeof currentUserRoles === 'string') {
-      return roles.some(
-        (allowedRole) => currentUserRoles === allowedRole
-      )
    }
  }

  // roles not found
  return false
}
```
</details>




### `getCurrentUser` in `src/lib/auth`
Depending on the auth provider you have setup - i.e. anything but dbAuth - at the time of setup, we cannot know the shape of your decoded token, because it could change based on your account settings. For example, you may choose to include roles or other metadata.

You'll have to make sure your getCurrentUser function is typed. For example:

TODO add generic for GetCurrentUser

```
// ./api/src/lib/auth.ts


```

### Calling service functions
